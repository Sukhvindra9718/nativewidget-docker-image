// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
import "mx-global";
import { Big } from "big.js";
import Geodecoder from 'react-native-geocoder';

// BEGIN EXTRA CODE
// END EXTRA CODE

/**
 * @param {string} address
 * @param {"NanoflowCommons.GeocodingProvider.Google"|"NanoflowCommons.GeocodingProvider.Geocodio"|"NanoflowCommons.GeocodingProvider.LocationIQ"|"NanoflowCommons.GeocodingProvider.MapQuest"} geocodingProvider
 * @param {string} providerApiKey
 * @returns {Promise.<MxObject>}
 */
export async function GeoCode(address, geocodingProvider, providerApiKey) {
	// BEGIN USER CODE
    const defaultCoordinates = { lat: "0.000000", long: "0.000000" };  // Default coordinates
    
    if (!address) {
        return Promise.reject(new Error("Input parameter 'Address' is required"));
    }

    if (navigator && navigator.product === "ReactNative") {
        return Geodecoder.geocodeAddress(address).then(results => {
            if (results.length === 0) {
                // Return default coordinates if no results are found
                return createMxObject(defaultCoordinates.lat, defaultCoordinates.long);
            }
            return createMxObject(String(results[0].position.lat), String(results[0].position.lng));
        }).catch(() => {
            // In case of any error, return default coordinates
            return createMxObject(defaultCoordinates.lat, defaultCoordinates.long);
        });
    }

    if (!geocodingProvider) {
        return Promise.reject(new Error("Input parameter 'Geocoding provider' is required for use on web"));
    }

    if (!providerApiKey) {
        return Promise.reject(new Error("Input parameter 'Provider api key' is required for use on web"));
    }

    const url = getApiUrl(geocodingProvider, address, providerApiKey);

    return fetch(url)
        .then(response => response.json().catch(() => response.text().then(text => {
            return Promise.reject(new Error(text));
        })))
        .then(response => getLatLong(geocodingProvider, response))
        .then(latLong => createMxObject(latLong[0], latLong[1]))
        .catch(() => {
            // Return default coordinates in case of an error
            return createMxObject(defaultCoordinates.lat, defaultCoordinates.long);
        });

    function getApiUrl(provider, query, key) {
        query = encodeURIComponent(query);
        key = encodeURIComponent(key);
        switch (provider) {
            case "Google":
                return `https://maps.googleapis.com/maps/api/geocode/json?address=${query}&key=${key}`;
            case "Geocodio":
                return `https://api.geocod.io/v1.3/geocode?q=${query}&api_key=${key}`;
            case "LocationIQ":
                return `https://eu1.locationiq.com/v1/search.php?format=json&q=${query}&key=${key}`;
            case "MapQuest":
                return `https://open.mapquestapi.com/geocoding/v1/address?location=${query}&key=${key}`;
        }
    }

    function getLatLong(provider, response) {
        switch (provider) {
            case "Google":
                if (response.status !== "OK") {
                    return [defaultCoordinates.lat, defaultCoordinates.long];  // Return default if no results
                }
                return [response.results[0].geometry.location.lat, response.results[0].geometry.location.lng];
            case "Geocodio":
                if (response.error || response.results.length === 0) {
                    return [defaultCoordinates.lat, defaultCoordinates.long];  // Return default if no results
                }
                return [response.results[0].location.lat, response.results[0].location.lng];
            case "LocationIQ":
                if (response.error || response.length === 0) {
                    return [defaultCoordinates.lat, defaultCoordinates.long];  // Return default if no results
                }
                return [response[0].lat, response[0].lon];
            case "MapQuest":
                if (response.info.statuscode !== 0 || response.results.length === 0) {
                    return [defaultCoordinates.lat, defaultCoordinates.long];  // Return default if no results
                }
                return [response.results[0].locations[0].latLng.lat, response.results[0].locations[0].latLng.lng];
        }
    }

    function createMxObject(lat, long) {
        return new Promise((resolve, reject) => {
            mx.data.create({
                entity: "NanoflowCommons.Position",
                callback: mxObject => {
                    mxObject.set("Latitude", lat);
                    mxObject.set("Longitude", long);
                    resolve(mxObject);
                },
                error: () => {
                    reject(new Error("Could not create 'NanoflowCommons.Position' object to store coordinates"));
                }
            });
        });
    }
	// END USER CODE
}
